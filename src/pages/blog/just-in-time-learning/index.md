---
path: "/blog/just-in-time-learning"
date: "07-06-2018"
title: "Just-in-Time Knowledge: Learn What You Need, When You Need It"
---

Like most knowledge workers, I’m someone who prides myself in my ability to learn and adapt to change.

As makers, we’re always looking for creative new ways to keep our minds sharp and skills relevant. We live in an age where a vast sea of information is available at our fingertips. **In this knowledge economy, information is king**. When you take a step back to consider the possibilities this creates for personal and societal growth, it’s really quite inspiring.

But what are the ramifications of such boundless access to information?

The JavaScript community has been in a [state of fatigue](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4) for some time due to constant changes in tooling, libraries and abstractions that seem to be popping up quicker than we’re able to absorb. While the growth and influence JavaScript has had on the development community is [something to admire](https://medium.com/javascript-scene/why-im-thankful-for-js-fatigue-i-know-you-re-sick-of-those-words-but-this-is-different-296fae0c888f) , it came at a cost. An onslaught of blog posts, books, video tutorials, online courses and bootcamps, all claiming to teach you the latest and greatest in your field of choice.

**Information overload is real** and its negative effects will [creep up on you](https://en.wikipedia.org/wiki/Boiling_frog).

As you begin your hunt for knowledge, you’re faced with some challenging questions:

- Am I finding all the information I need?
- Is the information I found reliable?
- Am I looking for the _right_ things?

Instead of stretching your mind beyond it’s limits by consuming 100% of the information you come across _in case_ you might need it, why not **learn as you need it**?

## Just-in-Case vs Just-in-Time Learning

> “Experience is a hard teacher because she gives you the test first, the lesson afterward” - Vernon Law

Most of us are accustomed to the format of education provided by traditional schooling. Teachers instruct classrooms of students using standardized material at a fixed rate. Changes to this material are infrequent, and students are often grouped without taking different styles of learning into consideration. You’re periodically tested on the materials that you’ve been taught.

This is **just-in-case learning**, and it’s the opposite of what you experience in life outside of school. You either acquire raw knowledge without knowing how it may (or may not) be applied at a later time, or you face challenges before you learn what you need. Life is full of twists and turns. You never know what you’ll face next.

If the information you’re learning is not immediately valuable or applied regularly, you end up forgetting the bulk of it. You’ll maintain some level of familiarity over time, but any detailed expertise will be lost.

This method of learning is comparable to the way we regularly consume daily tech news, deep-dive blog posts and lengthy Twitter rants. While the information may be valuable, internalizing it now before you’re presented the opportunity to make use of it is wasteful. At some point, you begin to experience diminishing returns on your investment of time and cognition.

To explain the alternative to this approach, let’s take a look at [JIT compilers](https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/).

Compilers translate the code you write to something a machine can understand. Traditional compilers work ahead of time to create an optimized translation of what we write. Modern JIT compilers, on the other hand, translate individual parts of your code as they become _warm_ (ie. as they are used).

These segments of code are translated into _stubs_, which are then further optimized and re-translated in a more performant manner as their usage increases. If your code’s execution changes and the compiler notices something is amiss, it throws out the stub and starts again. In this manner, the compiler is self-correcting and only commits to work on a translation if the value returned is deemed positive (ie. usage vs effort to optimize).

At it’s core, **just-in-time learning** can be explained using the principles that are baked into JIT compilers.

### Effectiveness > Efficiency

Traditional compilers are very efficient. They take their time, reading over the entirety of your code before translating it in the most efficient way possible. You can become very efficient at reading and processing information, committing vast amounts of your time to consuming as much knowledge as possible.

This isn’t the best way to learn.

Instead of focusing on _efficiency_, stop and ask yourself if you’re learning the right thing?

> Too often, we focus our time on “getting things done” instead of “getting the right things done”.

Whether it’s [personal](https://hackernoon.com/productivity-by-sam-altman-5d10d72f14d1) or [team productivity](https://www.amazon.ca/Rework-Jason-Fried/dp/0307463745), take your time and make sure you’re heading in the right direction. Only apply effort when it maximizes value.

Delivery teams put high emphasis on reaching peak velocity. Understand that [velocity is the combination of speed _and_ direction](https://fs.blog/2018/03/speed-velocity/).

### Correct Yourself

While translating, JIT compilers will immediately throw away existing optimizations if newly interpreted logic disproves previous assumptions.

As you learn “on the fly”, you will come across information that falsifies your previous knowledge. Heed these discoveries, as they could be an indication of questionable sources. Don’t let confirmation bias take hold and consider where you’re getting your information.

When you’re learning something new for work, you’ll likely be pressed for time. With a deadline looming, you’ll be tempted to rush your learning to get the job done.

Once again, direction matters. Validate against your network, filter out dogmatic opinions and do your best to ensure your information is credible.

### Organize Information

As a JIT compiler parses your code, it segments logic and creates _stubs_ that are indexed by line number and variable type. This indexing makes sorting, filtering and searching for relevant parts of your code a breeze during optimizations.

As you go about your day, communicating with co-workers, skimming newsletters and scrolling through your news feeds, you’ll come across some potentially interesting and useful information.

If you were to sit down, collect all that information and fully digest it on a daily basis, you’d be swamped. There is only so much time in a day. That being said, you wouldn’t want to discard what you found, potentially missing out on some key learnings.

Find a service, like [Pocket](https://getpocket.com/) or [Instapaper](https://www.instapaper.com/u) , that let’s you collect useful links for later. Like a compiler’s stubs, you’ll want your service to support search, categorization, tagging, sorting and filtering for easy access. Determine what groupings work best for your learning style and ensure they’re readily available when you need it.

Determining the value of an article often doesn’t require it’s full consumption. Most bloggers include the gist of what they’ve written in their conclusions. Skimming that will often give you enough context to decide wether or not the post should be saved for later.

## There’s a Caveat

> “The more basic knowledge you have … the less new knowledge you have to get.” - Charlie Munger

While the benefits are enticing, **just-in-time learning does not replace knowing the basics**.

Schools teach you fundamentals for good reason. They’re the building blocks used to develop a deeper, more specialized understanding of the subject matter at hand. Without that [foundation](https://fs.blog/2013/08/choose-your-next-book/), you'll have a hard time ramping up on new material. Starting from something is easier than starting from scratch.

In addition to knowing the basics, you should also **know the landscape**.

Broad knowledge and surface-level understanding of the many edges and specialties of your field will help optimize your just-in-time learning. Otherwise, how will you know _what_ to learn when you're faced with an unfamiliar problem? You need to be aware of your options before you can decide where to invest your learning.

The more you know, the better primed you will be to tackle new challenges. Continuous learning is key to personal development and success. [Growing smarter every day](https://fs.blog/2013/05/the-buffett-formula-how-to-get-smarter/) will compound and propel you ahead.

## What To Do When You Don’t Know

> “Education is knowing what to do when you don’t know.” - Michael Lewis, The Undoing Project

At the end of the day, a good mix is key. Invest time in learning the fundamentals of your craft, while building a framework of resources and techniques to prepare you for when you _don’t_ know.

Remember the core principles of just-in-time-learning:

1.  **Focus on effectiveness** by regularly asking yourself whether you’re learning the _right_ thing?
1.  **Correct yourself** when you come across conflicting data. Validate your sources and avoid dogmatic opinions.
1.  **Organize your information** in such a way that is painless to access just as you need it.

Don’t invest the time and effort into learning something in case you’ll need it. Learn _when_ you need it.
